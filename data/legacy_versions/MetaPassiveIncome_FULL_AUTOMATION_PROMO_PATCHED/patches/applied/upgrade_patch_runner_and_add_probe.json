[
    {
      "action": "replace_function",
      "file": "patch_runner.py",
      "function": "apply_patch",
      "code": "def apply_patch(patch):\n    \"\"\"패치 적용 엔진(업그레이드 버전)\n\n    지원 action:\n      - replace_function: 파일 내 함수 블록 교체\n      - insert_before: anchor 앞에 코드 삽입\n      - replace_text: 텍스트 치환\n      - create_file: 파일 생성/덮어쓰기\n      - grep_project: 프로젝트 전체에서 키워드 탐색(파일/라인 출력)\n\n    주의:\n      - 모든 변경은 백업 후 수행\n      - 파일은 PROJECT_ROOT 기준으로 탐색\n    \"\"\"\n\n    import os\n\n    action = patch.get('action')\n\n    # ---- 1) create_file: 새 파일 생성/덮어쓰기 ----\n    if action == 'create_file':\n        rel_path = patch.get('path')\n        content = patch.get('content', '')\n        if not rel_path:\n            print('[ERROR] create_file requires path')\n            return\n\n        abs_path = os.path.join(PROJECT_ROOT, rel_path)\n        os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n\n        # 기존 파일이 있으면 백업\n        if os.path.exists(abs_path):\n            backup_file(abs_path)\n\n        write_file(abs_path, content)\n        print(f\"[CREATE] File written: {rel_path}\")\n        return\n\n    # ---- 2) grep_project: 프로젝트 전체 키워드 스캔 ----\n    if action == 'grep_project':\n        keywords = patch.get('keywords') or []\n        exts = patch.get('exts') or ['.py', '.html', '.js', '.json', '.md']\n        max_hits = int(patch.get('max_hits') or 200)\n\n        if not keywords:\n            print('[ERROR] grep_project requires keywords')\n            return\n\n        hits = []\n        for root, _, files in os.walk(PROJECT_ROOT):\n            for fn in files:\n                if not any(fn.lower().endswith(e) for e in exts):\n                    continue\n                fp = os.path.join(root, fn)\n                try:\n                    text = read_file(fp)\n                except Exception:\n                    continue\n\n                lines = text.splitlines()\n                for i, line in enumerate(lines, start=1):\n                    for kw in keywords:\n                        if kw and kw in line:\n                            rel = os.path.relpath(fp, PROJECT_ROOT)\n                            hits.append((rel, i, line.strip()))\n                            if len(hits) >= max_hits:\n                                break\n                    if len(hits) >= max_hits:\n                        break\n                if len(hits) >= max_hits:\n                    break\n            if len(hits) >= max_hits:\n                break\n\n        if not hits:\n            print('[GREP] No hits found.')\n            return\n\n        print(f\"[GREP] Found {len(hits)} hit(s):\")\n        for rel, ln, s in hits:\n            print(f\" - {rel}:{ln} | {s}\")\n        return\n\n    # ---- 이하: 기존 3종 액션(파일 탐색 기반) ----\n    filename = patch.get('file')\n    if not filename:\n        print('[ERROR] patch requires file field')\n        return\n\n    path = find_file(filename)\n    if not path:\n        print(f\"[ERROR] File not found: {filename}\")\n        return\n\n    content = read_file(path)\n\n    # ---- replace_function ----\n    if action == 'replace_function':\n        func_name = patch.get('function')\n        new_code = patch.get('code', '')\n\n        if not func_name or not new_code:\n            print('[ERROR] replace_function requires function and code')\n            return\n\n        # 함수 시작점 찾기(정확도 향상: 라인 시작 def)\n        marker = f\"def {func_name}(\"\n        start = content.find(marker)\n        if start == -1:\n            print(f\"[SKIP] Function {func_name} not found in {filename}\")\n            return\n\n        # 함수 끝점 찾기: 다음 최상위 def/class 또는 EOF\n        rest = content[start:]\n        end = None\n        m = None\n        # 다음 'def ' 또는 'class '가 줄 시작에서 등장하는 지점\n        import re\n        m = re.search(r\"\\n(def|class)\\s+\", rest)\n        if m:\n            end = start + m.start() + 1\n        else:\n            end = len(content)\n\n        backup_file(path)\n        updated = content[:start] + new_code.strip() + \"\\n\\n\" + content[end:]\n        write_file(path, updated)\n        print(f\"[PATCH] Function replaced: {func_name} in {filename}\")\n        return\n\n    # ---- insert_before ----\n    if action == 'insert_before':\n        anchor = patch.get('anchor')\n        snippet = patch.get('code', '')\n\n        if not anchor or not snippet:\n            print('[ERROR] insert_before requires anchor and code')\n            return\n\n        if snippet in content:\n            print(f\"[SKIP] Snippet already exists in {filename}\")\n            return\n\n        if anchor not in content:\n            print(f\"[WARN] Anchor not found in {filename}: {anchor}\")\n            return\n\n        backup_file(path)\n        updated = content.replace(anchor, snippet + \"\\n\" + anchor)\n        write_file(path, updated)\n        print(f\"[PATCH] Inserted snippet before '{anchor}' in {filename}\")\n        return\n\n    # ---- replace_text ----\n    if action == 'replace_text':\n        old = patch.get('old', '')\n        new = patch.get('new', '')\n\n        if not old:\n            print('[ERROR] replace_text requires old')\n            return\n\n        if old not in content:\n            print(f\"[SKIP] Text not found in {filename}\")\n            return\n\n        backup_file(path)\n        write_file(path, content.replace(old, new))\n        print(f\"[PATCH] Text replaced in {filename}\")\n        return\n\n    print(f\"[ERROR] Unknown action: {action}\")"
    },
    {
      "action": "create_file",
      "path": "tools/probe_deploy.py",
      "content": "# -*- coding: utf-8 -*-\n\"\"\"프로젝트 배포/메인페이지 설정 위치를 자동 탐지하는 스캐너\n\n사용법(프로젝트 루트에서):\n  python tools/probe_deploy.py\n\n기능:\n  - 배포 관련 로그/키워드가 포함된 파일과 라인번호를 출력\n  - 특히 'main page', 'Vercel', 'Completed setting' 같은 문구를 찾음\n\n주의:\n  - 이 스크립트는 '수정'을 하지 않습니다. 위치를 '찾기'만 합니다.\n\"\"\"\n\nimport os\n\nPROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n\nKEYWORDS = [\n    'Vercel optimized distribution',\n    'Worldwide distribution completed',\n    'Completed setting',\n    'main page',\n    'Web3_SaaS_UI_99',\n    'set_main',\n    'vercel',\n    'deploy',\n]\n\nEXTS = {'.py', '.html', '.js', '.json', '.md'}\n\n\ndef read_text(fp: str) -> str:\n    with open(fp, 'r', encoding='utf-8', errors='ignore') as f:\n        return f.read()\n\n\ndef main():\n    hits = []\n\n    for root, _, files in os.walk(PROJECT_ROOT):\n        for fn in files:\n            ext = os.path.splitext(fn)[1].lower()\n            if ext not in EXTS:\n                continue\n\n            fp = os.path.join(root, fn)\n            try:\n                text = read_text(fp)\n            except Exception:\n                continue\n\n            for i, line in enumerate(text.splitlines(), start=1):\n                for kw in KEYWORDS:\n                    if kw and kw.lower() in line.lower():\n                        rel = os.path.relpath(fp, PROJECT_ROOT)\n                        hits.append((rel, i, line.strip()))\n\n    if not hits:\n        print('[PROBE] No hits found. (배포 로그 문자열이 동적일 가능성이 큼)')\n        print('[PROBE] 다음으로는 deploy_module*.py / auto_pilot.py 에서 print(...) 호출을 전부 스캔해야 합니다.')\n        return\n\n    print(f'[PROBE] Found {len(hits)} hit(s):')\n    for rel, ln, s in hits:\n        print(f' - {rel}:{ln} | {s}')\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ]
  